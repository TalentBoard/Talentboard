{"version":3,"file":"fromRef.js","sourceRoot":"","sources":["../../../../src/database/observable/fromRef.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,UAAU,EAAE,MAAM,MAAM,CAAC;AAElC,OAAO,EAAE,GAAG,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,gBAAgB,CAAC;AAYnD,MAAM,kBAAqB,GAAkB,EAAE,KAAkB,EAAE,UAAiB;IAAjB,2BAAA,EAAA,iBAAiB;IAClF,MAAM,CAAC,IAAI,UAAU,CAAqB,UAAA,UAAU;QAClD,IAAM,EAAE,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,KAAK,EAAE,UAAC,QAAQ,EAAE,OAAO;YAClD,UAAU,CAAC,IAAI,CAAC,EAAE,QAAQ,UAAA,EAAE,OAAO,SAAA,EAAE,CAAC,CAAC;YACvC,EAAE,CAAC,CAAC,UAAU,IAAI,MAAM,CAAC,CAAC,CAAC;gBAAC,UAAU,CAAC,QAAQ,EAAE,CAAC;YAAC,CAAC;QACtD,CAAC,EAAE,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;QACtC,EAAE,CAAC,CAAC,UAAU,IAAI,IAAI,CAAC,CAAC,CAAC;YACvB,MAAM,CAAC,EAAE,WAAW,gBAAK,GAAG,CAAC,GAAG,CAAC,KAAK,EAAE,EAAE,CAAC,CAAA,CAAA,CAAC,EAAE,CAAC;QACjD,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,CAAC,EAAE,WAAW,gBAAK,CAAC,EAAE,CAAC;QAC/B,CAAC;IACH,CAAC,CAAC,CAAC,IAAI,CACL,GAAG,CAAC,UAAA,OAAO;QACD,IAAA,2BAAQ,EAAE,yBAAO,CAAa;QACtC,IAAI,GAAG,GAAkB,IAAI,CAAC;QAC9B,EAAE,CAAC,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;YAAC,GAAG,GAAG,QAAQ,CAAC,GAAG,CAAC;QAAC,CAAC;QAC9C,MAAM,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,OAAO,SAAA,EAAE,GAAG,KAAA,EAAE,CAAC;IAC1D,CAAC,CAAC,EAIF,KAAK,CAAC,CAAC,CAAC,EACR,KAAK,EAAE,CACR,CAAC;AACJ,CAAC","sourcesContent":["import { DatabaseQuery, DatabaseSnapshot, ListenEvent, AngularFireAction } from '../interfaces';\nimport { Observable } from 'rxjs';\nimport { FirebaseZoneScheduler } from '@angular/fire';\nimport { map, delay, share } from 'rxjs/operators';\n\ninterface SnapshotPrevKey<T> {\n  snapshot: DatabaseSnapshot<T>;\n  prevKey: string | null | undefined;\n}\n\n/**\n * Create an observable from a Database Reference or Database Query.\n * @param ref Database Reference\n * @param event Listen event type ('value', 'added', 'changed', 'removed', 'moved')\n */\nexport function fromRef<T>(ref: DatabaseQuery, event: ListenEvent, listenType = 'on'): Observable<AngularFireAction<DatabaseSnapshot<T>>> {\n  return new Observable<SnapshotPrevKey<T>>(subscriber => {\n    const fn = ref[listenType](event, (snapshot, prevKey) => {\n      subscriber.next({ snapshot, prevKey });\n      if (listenType == 'once') { subscriber.complete(); }\n    }, subscriber.error.bind(subscriber));\n    if (listenType == 'on') {\n      return { unsubscribe() { ref.off(event, fn)} };\n    } else {\n      return { unsubscribe() { } };\n    }\n  }).pipe(\n    map(payload =>  {\n      const { snapshot, prevKey } = payload;\n      let key: string | null = null;\n      if (snapshot.exists()) { key = snapshot.key; }\n      return { type: event, payload: snapshot, prevKey, key };\n    }),\n    // Ensures subscribe on observable is async. This handles\n    // a quirk in the SDK where on/once callbacks can happen\n    // synchronously.\n    delay(0),\n    share()\n  );\n}\n"]}